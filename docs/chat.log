LookFlex 의사결정 로그
프로젝트 진행 과정에서 내려진 주요 결정들을 시간순으로 기록합니다.

================================================================================
[2026-02-28] 프로젝트 기획 및 기술 스택 선정
================================================================================

배경
----
Google Looker Studio를 사내 BI 대시보드로 사용 중이었으나 다음 문제로 대체 결정:

  - 그리드 간격이 넓어 테이블 배치 위치 조정이 어려움
  - Viewer 권한 사용자가 메트릭을 바꾸려면 헤더의 작은 아이콘을 찾아 클릭해야 하는
    비직관적인 UX
  - 조건부 서식을 열 단위로 마우스 UI를 통해 하나씩 설정해야 하는 비효율

Grafana 등 오픈소스 플랫폼도 검토했으나, 실시간 시계열보다 테이블 데이터 위주이고
ETL은 배치 처리 방식이라 범용 오픈소스보다 직접 구축이 더 적합하다고 판단.

결정된 기술 스택
----------------
프론트엔드:
  - Next.js 14+ (App Router) + TypeScript
  - TanStack Table v8 — 조건부 서식·컬럼 커스터마이징을 코드 레벨에서 완전 제어
  - Apache ECharts (echarts-for-react)
  - TanStack Query, Zustand, Tailwind CSS + shadcn/ui

백엔드:
  - FastAPI (Python 3.11+)
  - SQLAlchemy 2.0 (async) + Alembic
  - JWT 인증 (python-jose + passlib/bcrypt)

데이터베이스 / 인프라:
  - PostgreSQL 16 (주 DB — 사용자 계정, 대시보드 설정)
  - Redis 7 (캐시)
  - Docker + Docker Compose
  - Nginx (리버스 프록시)

주요 설계 결정
--------------
  - 사용자별 커스터마이징 설정(메트릭 선택, 조건부 서식, 컬럼 너비 등)은
    PostgreSQL JSONB 컬럼으로 저장
  - 역할: Admin / Editor / Viewer 3단계 분리
  - Access Token(메모리) + Refresh Token(HttpOnly Cookie) 방식
  - 로컬 서버 우선, Docker Compose 기반으로 향후 클라우드 이전 용이하게 설계

================================================================================
[2026-02-28] 백엔드 서버 선택 — FastAPI vs NestJS vs Spring Boot
================================================================================

검토 배경
---------
  - 차트(JavaScript) 구현이 중요한데, Python 백엔드로 괜찮은지 확인 필요
  - BigQuery + PostgreSQL 연동, 향후 다양한 DB 지원(SaaS 확장) 고려
  - Text2SQL 등 AI 기능 추가 가능성 검토
  - Node.js 기반 NestJS나 Java 기반 Spring Boot와의 비교 요청

핵심 전제
---------
차트 렌더링은 백엔드와 무관하다. ECharts 등 차트 라이브러리는 브라우저에서 동작하고,
백엔드는 JSON 데이터를 내려주기만 한다. 백엔드 언어와 무관하게 Next.js에서 모든 차트
구현이 가능하다.

비교 결과
---------
  항목                    FastAPI              NestJS           Spring Boot
  BigQuery 연동          ★★★ Python SDK      ★★☆             ★★☆ JDBC
  다중 DB 지원           ★★☆ SQLAlchemy      ★★☆             ★★★ 네이티브 JDBC
  Text2SQL / AI 연동     ★★★ LangChain 등    ★☆☆ 별도 필요   ★☆☆ 별도 필요
  데이터 처리(pandas 등) ★★★                 ★☆☆             ★☆☆
  개발 속도              ★★★ OpenAPI 자동    ★★★             ★★☆ 보일러플레이트
  SaaS 대규모 확장       ★★☆                 ★★☆             ★★★ 엔터프라이즈

JDBC 관련: Python(SQLAlchemy)도 PostgreSQL·MySQL·MSSQL·Oracle·Snowflake 등 주요 DB를
자체 드라이버로 커버한다. 순수 JDBC 드라이버만 존재하는 레거시 JVM DB 연결이 필요한
경우만 Spring이 유리하다.

NestJS/Spring에서 AI 기능을 원하면 결국 Python 서비스를 별도로 띄워야 하므로 스택이
복잡해진다.

결정: FastAPI 유지
------------------
현재 요구사항(BigQuery + PostgreSQL)과 미래 요구사항(Text2SQL, AI 기능, 다중 DB SaaS)
모두에서 Python 생태계가 가장 직접적으로 대응한다.

재검토 조건: SaaS로 확장 시 수천 명 동시 사용자, 멀티테넌시, 복잡한 트랜잭션 관리가
필요해지는 시점에 Spring Boot 기반 비즈니스 로직 서버 분리를 검토한다.

================================================================================
[2026-02-28] API 문서 작성 (api.md)
================================================================================

작업 내용
---------
api-plan.md의 기능 기획을 바탕으로 바이브 코딩용 REST API 명세서 api.md를 작성했다.

문서 구조
---------
  베이스 URL: http://localhost:8000/api/v1
  공통 응답 envelope {success, data, error}, 페이지네이션 구조, 전체 Enum 정의 포함
  총 13개 도메인, 약 60개 엔드포인트

  1.  Auth                회원가입, 이메일 인증, 로그인, JWT 갱신, 로그아웃, 비밀번호 재설정
  2.  Users               프로필, 비밀번호 변경, 관리자 역할/그룹 일괄 변경
  3.  Groups              DEPARTMENT/POSITION/CUSTOM 그룹 CRUD
  4.  Dashboards & Pages  대시보드/페이지 CRUD, 즐겨찾기, 순서 변경, 복제
  5.  Data Sources        DB 연결, 파일 업로드, 연결 테스트, 스키마 동기화, 권한, 미리보기
  6.  Charts              CRUD, 스타일, 위치 일괄 저장, 차트 그룹, 데이터 조회, XLSX/CSV 내보내기
  7.  Filters             DROPDOWN/TEXT_INPUT/RANGE/DATE_RANGE, 기본 필터 고정
  8.  Cond. Formatting    CRUD, 우선순위 변경, 다른 차트로 복사
  9.  User View Configs   사용자별 메트릭/정렬/컬럼 너비 개인 설정 (Viewer 포함 전 역할)
  10. Number Formats      사전 정의 포맷 목록
  11. Notifications       목록 조회, 읽음 처리
  12. SMTP Admin          이메일 서버 설정/테스트
  13. System              헬스체크, 감사 로그

api-plan.md 대비 추가된 항목
-----------------------------
  - 비밀번호 재설정 플로우 (이메일 발송 → 토큰 검증 → 변경)
  - 데이터소스 연결 테스트, 스키마 동기화, 데이터 미리보기
  - 차트 XLSX/CSV 내보내기
  - 사용자별 뷰 설정 (User View Configs)
  - SMTP 관리자 설정
  - 감사 로그 (Audit Log)

================================================================================
[2026-02-28] 인프라 아키텍처 설계 (infra.md)
================================================================================

작업 내용
---------
프로젝트 폴더 구조, Docker 전략, DB 초기화, Redis 구성, Git 브랜치 전략을 포괄하는
infra.md를 작성했다. (구 architecture.md)

주요 결정 사항
--------------
모노레포 구조 채택:
  - Turborepo/Nx 미사용 — 프론트(npm), 백엔드(pip) 패키지 매니저 독립 유지
  - 하나의 PR로 프론트·백엔드·인프라 변경을 함께 추적

Docker Compose 채택 (minikube/K8s 대신):
  - 100명 미만 규모에서 K8s는 오버엔지니어링
  - kompose convert로 향후 K8s 마이그레이션 가능
  - 전환 검토 시점: SaaS 전환 및 수백 명 이상 동시 사용자, 무중단 배포 요건 발생 시

DB 초기화 2단계 전략:
  - 1단계: infra/postgres/init/*.sql — PostgreSQL 확장 활성화 (uuid-ossp, pgcrypto,
    pg_trgm), 볼륨 최초 생성 시 1회 실행
  - 2단계: Alembic upgrade head — 백엔드 컨테이너 시작 시마다 실행, 테이블 스키마 관리

Redis 역할 정의:
  - OTP 코드 (10분), 비밀번호 재설정 토큰 (1시간), JWT 블랙리스트,
    쿼리 결과 캐시 (5~30분), 알림 카운터
  - maxmemory-policy allkeys-lru, 영속성 비활성화 (재시작 시 유실 허용)
  - Redis 비밀번호는 환경변수 주입이 어려워 redis.conf 파일로 관리

Git 브랜치 전략 — GitHub Flow:
  - 영구 브랜치: main (운영), dev (개발 통합)
  - 작업 브랜치: feature/*, fix/*, hotfix/*, chore/*
  - 네이밍: feature/{도메인}-{요약} (예: feature/auth-register-flow)
  - hotfix/*는 main과 dev 모두 병합
  - Conventional Commits 형식, Semantic Versioning 태그 (main 병합 시)
  - 브랜치는 서비스별(백엔드/프론트)이 아닌 도메인 기준으로 분기

문서 파일명 표준 결정:
  - 루트 특수 파일: UPPERCASE (GitHub 자동 인식 — README.md, LICENSE)
  - docs/ 내 일반 문서: lowercase-kebab-case, 확장자 자유
  - architecture.md → infra.md (내용이 인프라/배포 중심)
  - 문서는 docs/ 폴더에서 일괄 관리, README.md·LICENSE는 루트 유지

================================================================================
[2026-02-28] 프로젝트 초기 스캐폴딩 구현 (chore: initial project scaffold)
================================================================================

작업 내용
---------
infra.md 설계를 바탕으로 전체 프로젝트 뼈대를 생성했다.
Git 커밋 규칙: 커밋 생성 직전에 chat.log에 작업 내역을 먼저 기록한다.

생성된 파일 목록 (총 39개)
---------------------------
루트 설정:
  - .gitignore         — Python/Node.js/env 파일 제외, docs/chat.log 명시적 언트래킹 방지
  - .env.example       — 전체 환경변수 목록 (빈값 + 주석)
  - Makefile           — dev, dev-down, prod, prod-down, migrate, makemigration, logs, ps

Docker Compose:
  - docker-compose.yml      — 기본 서비스 정의 (postgres, redis, backend, frontend, nginx)
  - docker-compose.dev.yml  — 개발 오버라이드 (포트 노출, 볼륨 마운트, 핫리로드)
  - docker-compose.prod.yml — 운영 오버라이드 (443포트, 리소스 제한, json-file 로깅)

인프라 설정:
  - infra/nginx/nginx.conf          — Nginx 베이스 설정, client_max_body_size 50M
  - infra/nginx/conf.d/local.conf   — HTTP 프록시 (API → backend:8000, / → frontend:3000)
  - infra/nginx/conf.d/prod.conf    — HTTPS 템플릿 (certbot 적용 전 주석 처리)
  - infra/nginx/Dockerfile          — FROM nginx:1.27-alpine
  - infra/postgres/init/00_create_extensions.sql — uuid-ossp, pgcrypto, pg_trgm 확장
  - infra/redis/redis.conf          — requirepass, maxmemory 256mb, allkeys-lru, 영속성 비활성화

백엔드 골격 (apps/backend/):
  - Dockerfile           — 멀티스테이지 운영 빌드 (builder → runner)
  - Dockerfile.dev       — uvicorn --reload 개발용
  - pyproject.toml       — 전체 의존성 (fastapi, sqlalchemy[asyncio], alembic, jwt, redis 등)
  - alembic.ini          — Alembic 기본 설정
  - entrypoint.sh        — alembic upgrade head 후 gunicorn 실행
  - app/main.py          — FastAPI 앱, CORS 미들웨어, /api/v1/health 엔드포인트
  - app/core/config.py   — Pydantic BaseSettings, 전체 환경변수 매핑
  - app/db/base.py       — SQLAlchemy DeclarativeBase
  - app/db/session.py    — AsyncSession 팩토리, get_db 의존성
  - alembic/env.py       — 비동기 Alembic env, settings 연동
  - alembic/script.py.mako — 마이그레이션 파일 템플릿
  - alembic/versions/.gitkeep
  - app/api/__init__.py, app/core/__init__.py, app/db/__init__.py
  - app/db/models/__init__.py, app/schemas/__init__.py
  - app/services/__init__.py, app/repositories/__init__.py
  - tests/__init__.py

커밋 규칙 추가
--------------
앞으로 Git 커밋 생성 직전에 chat.log에 해당 커밋의 작업 내역을 먼저 기록한다.

완료 후 상태
------------
  - main 브랜치에 root commit 1개 (a6f069c)
  - dev 브랜치 생성 및 origin push 완료 (main, dev 모두)
  - git push 완료

다음 단계 (예정)
----------------
  1. feature/backend-models 브랜치에서 SQLAlchemy 모델 작성  ← 진행 예정
  2. Alembic 초기 마이그레이션 생성
  3. apps/frontend/ Next.js 스캐폴딩

================================================================================
[2026-02-28] SQLAlchemy 모델 및 Alembic 초기 마이그레이션
            (feat: add SQLAlchemy models and initial Alembic migration)
================================================================================

작업 내용
---------
api.md의 13개 도메인 전체를 커버하는 SQLAlchemy 2.0 async 모델을 작성하고
Alembic 초기 마이그레이션 파일을 수동으로 생성했다.
브랜치: feature/backend-models (dev 기준)

생성된 파일 (apps/backend/app/db/models/)
------------------------------------------
  enums.py        — 프로젝트 전체 Enum 정의 (12종)
                    Role, ApprovalStatus, GroupType, DSSourceType, FieldType,
                    AggregateType, ChartType, FilterType, FilterOp, SortDir,
                    CondFormatApplyTo, NotificationType, AuditAction

  user.py         — User, Group, RegisterRequest + user_group M2M 연결 테이블
                    User.role (OWNER/ADMIN/EDITOR/VIEWER), is_active, email_verified_at
                    RegisterRequest: 이메일 인증 → 관리자 승인 대기 플로우용

  dashboard.py    — Dashboard, Page, DashboardFavorite, PageFavorite
                    Page.dashboard_id nullable (독립 페이지 허용)
                    Page: x/y/width/height px 단위 캔버스, background_color

  datasource.py   — DataSource, DataSourceField, DataSourcePermission
                    connection_config: JSONB (암호화는 서비스 레이어에서 처리)
                    allow_all 플래그 + entity_type/entity_id 조합으로 Fine-grained 권한 관리

  chart.py        — Chart, ChartGroup, ChartGroupItem
                    Chart.config JSONB: 차트 타입별 설정 (dimensions, metrics 등)
                    Chart.style JSONB: 헤더/바디/합계행 스타일
                    ChartGroup: 여러 차트를 묶어 이동/크기조정 연동

  filter.py       — Filter, DefaultFilterRule
                    Filter: 페이지에 배치되는 인터랙티브 UI 요소
                    DefaultFilterRule.apply_to: "PAGE" 또는 chart_id 문자열

  formatting.py   — ConditionalFormat, ConditionalFormatRule
                    ConditionalFormat.order: 서식 평가 순서 (낮을수록 우선)
                    ConditionalFormatRule.style JSONB: backgroundColor, color, fontWeight 등

  view_config.py  — UserViewConfig
                    user_id + chart_id UNIQUE 제약 (사용자별 1개)
                    config JSONB: metrics, sort, columnWidths, frozenColumns, rowsPerPage

  notification.py — Notification
                    is_read, created_at 인덱스 포함

  system.py       — SmtpConfig (싱글턴 id=1), AuditLog
                    AuditLog.detail JSONB: 액션별 상세 (chartId, datasourceId 등)

  __init__.py     — 모든 모델 import (Alembic autogenerate 인식용)

생성된 마이그레이션 파일
------------------------
  alembic/versions/a1b2c3d4e5f6_initial_schema.py
    - Revision: a1b2c3d4e5f6, down_revision: None (root)
    - upgrade(): PostgreSQL Enum 타입 12종 생성 후 테이블 22개 생성
    - downgrade(): 역순 삭제 (FK 의존성 고려)
    - 수동 작성 (DB 연결 없이 생성, 컨테이너 첫 기동 시 자동 적용)

테이블 목록 (22개)
-------------------
  audit_logs, chart_group_items, chart_groups, charts,
  conditional_format_rules, conditional_formats,
  dashboard_favorites, dashboards,
  datasource_fields, datasource_permissions, datasources,
  default_filter_rules, filters, groups, notifications,
  page_favorites, pages, register_requests,
  smtp_configs, user_group, user_view_configs, users

검증 방법
---------
  conda run -n main python -c "from app.db.models import *; ..."
  → 22개 테이블 정상 등록 확인 (SQLAlchemy 2.0 업그레이드 필요: pip install sqlalchemy>=2.0)
  → alembic/versions/*.py AST 파싱 오류 없음

설계 결정 사항
--------------
  JSONB 사용 필드:
    - DataSource.connection_config — DB 연결 정보 (암호화 후 저장 예정)
    - Chart.config / style — 차트 타입별 설정/스타일 자유도 확보
    - Filter.config — 필터 타입별 설정
    - ConditionalFormatRule.value / second_value — 숫자·문자·null 통합 수용
    - UserViewConfig.config — 사용자 개인 뷰 오버라이드 전체
    - AuditLog.detail — 액션별 부가 정보

  소프트 딜리트 미채택: is_active(User만), 나머지는 CASCADE DELETE
  SmtpConfig: 싱글턴 패턴 (Integer PK id=1), 복수 설정 불필요

다음 단계 (예정)
----------------
  1. PR: feature/backend-models → dev 머지  ← 완료
  2. feature/auth 브랜치에서 Auth API 구현  ← 완료
  3. apps/frontend/ Next.js 스캐폴딩

================================================================================
[2026-02-28] Auth API 구현
            (feat(backend): implement Auth API endpoints)
================================================================================

작업 내용
---------
api.md §1 Auth 전체 10개 엔드포인트를 구현했다.
브랜치: feature/auth (dev 기준)

생성된 파일 목록
----------------
  app/core/security.py
    - hash_password / verify_password (bcrypt via passlib)
    - create_access_token (15분) / create_refresh_token (7일) (JWT via python-jose)
    - decode_token(token, token_type) → user_id 또는 None

  app/core/redis.py
    - aioredis.Redis 모듈 레벨 싱글턴
    - init_redis / close_redis (lifespan 훅에서 호출)
    - 키 네임스페이스 헬퍼: otp_key, pw_reset_key, jwt_blacklist_key

  app/core/deps.py
    - get_current_user: Bearer 토큰 검증 → User 객체 반환
    - CurrentUser: Annotated 타입 앨리어스
    - require_role(*roles): 역할 레벨 비교 의존성 팩토리

  app/schemas/common.py
    - ApiResponse[T]: {success, data, error} envelope
    - PaginatedData[T]: {items, total, page, limit, total_pages}

  app/schemas/auth.py
    - RegisterRequest, RegisterResponse
    - VerifyEmailRequest, ResendCodeRequest, MessageResponse
    - LoginRequest, TokenResponse
    - RegisterRequestItem, ProcessRegisterRequest, ProcessRegisterResponse
    - PasswordResetRequestBody, PasswordResetBody

  app/schemas/user.py
    - UserProfile, GroupSummary

  app/repositories/user_repository.py
    - UserRepository: get_by_id, get_by_email, create, save
    - RegisterRequestRepository: get_by_email_pending, get_by_id,
      create, list_by_status, save

  app/services/email_service.py
    - send_email: SMTP 미설정 시 logger.warning으로 fallback
    - send_otp_email, send_password_reset_email, send_approval_result_email

  app/services/auth_service.py
    - register: 중복 검사 → RegisterRequest 생성 → OTP 발송(Redis TTL 10분)
    - verify_email: OTP 검증 → email_verified_at 기록
    - resend_code: OTP 재생성 및 재발송
    - login: 비밀번호 검증 → AccessToken + RefreshToken 반환
    - refresh: Refresh JWT 검증 → 새 AccessToken 반환
    - list_register_requests: 상태별 페이지네이션 목록 (ADMIN)
    - process_register_request: 승인시 User 생성 / 거절시 reason 저장 (ADMIN)
    - password_reset_request: 재설정 토큰 Redis 저장 (TTL 1시간)
    - password_reset: 토큰 검증 → 비밀번호 변경

  app/api/v1/__init__.py (빈 파일)
  app/api/v1/router.py — api_router (prefix=/api/v1)
  app/api/v1/auth.py — 10개 엔드포인트 (prefix=/auth)
    POST   /auth/register
    POST   /auth/verify-email
    POST   /auth/resend-code
    POST   /auth/login           → RefreshToken HttpOnly 쿠키 Set-Cookie
    POST   /auth/refresh          → 쿠키에서 RefreshToken 읽기
    POST   /auth/logout           → 쿠키 삭제 (204)
    GET    /auth/register-requests  (ADMIN+)
    PATCH  /auth/register-requests/{requestId}  (ADMIN+)
    POST   /auth/password-reset-request
    POST   /auth/password-reset

수정된 파일
-----------
  app/main.py
    - lifespan asynccontextmanager 추가 (init_redis / close_redis)
    - api_router include (app/api/v1/router.py)

설계 결정 사항
--------------
  이메일 발송: asyncio.create_task로 fire-and-forget — SMTP 실패가 API 응답에 영향 없음
  비밀번호 재설정 URL: 프론트엔드 baseURL 하드코딩 (http://localhost:3000)
    → 추후 settings.FRONTEND_URL 환경변수로 교체 예정
  Refresh Token 쿠키 Path: /api/v1/auth/refresh — 다른 엔드포인트에 쿠키 전송 방지
  역할 레벨 비교: OWNER=4, ADMIN=3, EDITOR=2, VIEWER=1
    require_role(Role.ADMIN, Role.OWNER) → ADMIN 이상 허용

검증 방법
---------
  conda run -n main python -c "from app.main import app; ..."
  → All imports OK
  → Auth routes (10개) 정상 등록 확인

다음 단계 (예정)
----------------
  1. PR: feature/auth → dev 머지
  2. feature/users 브랜치에서 Users API 구현
  3. apps/frontend/ Next.js 스캐폴딩
